--- START OF FILE ProjectContext.txt ---

--- Folder Structure ---
images/
media/
src/
  test/


--- .gitignore ---
out
dist
node_modules
.vscode-test/
*.vsix


--- .vscode-test.mjs ---
import { defineConfig } from '@vscode/test-cli';

export default defineConfig({
	files: 'out/test/**/*.test.js',
});


--- .vscodeignore ---
.vscode/**
.vscode-test/**
out/**
node_modules/**
src/**
.gitignore
.yarnrc
esbuild.js
vsc-extension-quickstart.md
**/tsconfig.json
**/eslint.config.mjs
**/*.map
**/*.ts
**/.vscode-test.*


--- CHANGELOG.md ---
# Change Log

All notable changes to the "code-context-extractor" extension will be documented in this file.

Check [Keep a Changelog](http://keepachangelog.com/) for recommendations on how to structure this file.

## [1.1.0]

### Added
- **Whitelist (Include) Mode**: Added a new mode to start with an empty context and strictly select specific files or folders to include.
- **Binary File Detection**: Implemented a heuristic to detect binary files (images, executables, PDFs) and automatically exclude their raw content from the output file.
- **Rule Grouping**: In Exclude mode, rules are now organized into collapsible "Imported Rules" (from .gitignore) and "Custom Rules" sections.
- **Delete Functionality**: Added the ability to delete custom rules from the list.
- **State Persistence**: The extension now saves the selected mode and rule lists between sessions.

### Changed
- **UI Overhaul**: Replaced simple checkboxes with a grouped accordion layout and native-style toggle controls.
- Improved the recursive logic for un-ignoring folders in Whitelist mode to ensure nested files are captured correctly.

## [0.0.1]

- Initial release

--- esbuild.js ---
const esbuild = require("esbuild");

const production = process.argv.includes('--production');
const watch = process.argv.includes('--watch');

/**
 * @type {import('esbuild').Plugin}
 */
const esbuildProblemMatcherPlugin = {
	name: 'esbuild-problem-matcher',

	setup(build) {
		build.onStart(() => {
			console.log('[watch] build started');
		});
		build.onEnd((result) => {
			result.errors.forEach(({ text, location }) => {
				console.error(`✘ [ERROR] ${text}`);
				console.error(`    ${location.file}:${location.line}:${location.column}:`);
			});
			console.log('[watch] build finished');
		});
	},
};

async function main() {
	const ctx = await esbuild.context({
		entryPoints: [
			'src/extension.ts'
		],
		bundle: true,
		format: 'cjs',
		minify: production,
		sourcemap: !production,
		sourcesContent: false,
		platform: 'node',
		outfile: 'dist/extension.js',
		// Make sure 'vscode' is the ONLY external module.
		// We want esbuild to bundle 'ignore' and 'node-fetch'.
		external: ['vscode'], 
		logLevel: 'silent',
		plugins: [
			esbuildProblemMatcherPlugin,
		],
	});
	if (watch) {
		await ctx.watch();
	} else {
		await ctx.rebuild();
		await ctx.dispose();
	}
}

main().catch(e => {
	console.error(e);
	process.exit(1);
});


--- eslint.config.mjs ---
import typescriptEslint from "@typescript-eslint/eslint-plugin";
import tsParser from "@typescript-eslint/parser";

export default [{
    files: ["**/*.ts"],
}, {
    plugins: {
        "@typescript-eslint": typescriptEslint,
    },

    languageOptions: {
        parser: tsParser,
        ecmaVersion: 2022,
        sourceType: "module",
    },

    rules: {
        "@typescript-eslint/naming-convention": ["warn", {
            selector: "import",
            format: ["camelCase", "PascalCase"],
        }],

        curly: "warn",
        eqeqeq: "warn",
        "no-throw-literal": "warn",
        semi: "warn",
    },
}];

--- images/exclude_mode.png ---
[Binary file detected - content excluded]

--- images/include_mode.png ---
[Binary file detected - content excluded]

--- LICENSE ---
MIT License

Copyright (c) [2025] [Ct-dev]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--- media/icon.png ---
[Binary file detected - content excluded]

--- media/icon.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">

  <!-- Border -->
  <rect x="12" y="12" width="104" height="104" rx="12" ry="12"
        stroke="currentColor" stroke-width="10" fill="none"/>

  <!-- Left bracket -->
  <path d="M44 42 L28 64 L44 86"
        stroke="currentColor" stroke-width="10" stroke-linecap="round" stroke-linejoin="round" fill="none"/>

  <!-- Right bracket -->
  <path d="M84 42 L100 64 L84 86"
        stroke="currentColor" stroke-width="10" stroke-linecap="round" stroke-linejoin="round" fill="none"/>

  <!-- Text lines (centered and evenly spaced) -->
  <line x1="52" y1="54" x2="76" y2="54"
        stroke="currentColor" stroke-width="8" stroke-linecap="round"/>
  <line x1="52" y1="64" x2="76" y2="64"
        stroke="currentColor" stroke-width="8" stroke-linecap="round"/>
  <line x1="52" y1="74" x2="76" y2="74"
        stroke="currentColor" stroke-width="8" stroke-linecap="round"/>

</svg>


--- media/main.css ---
/* media/main.css */
body {
    font-family: var(--vscode-font-family);
    padding: 0 10px;
}

button {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: 1px solid var(--vscode-button-border);
    padding: 8px 12px;
    cursor: pointer;
    width: 100%;
    margin-top: 10px;
}

button:hover {
    background-color: var(--vscode-button-hoverBackground);
}

#rules-container {
    margin-top: 10px;
    max-height: 300px;
    overflow-y: auto;
}

/* --- RULE ITEMS & DELETE BUTTON --- */
.rule-item {
    display: flex;
    align-items: center;
    padding: 4px 0;
    /* Ensure label takes available space to push delete btn to right */
    justify-content: space-between; 
}

.rule-item input {
    margin-right: 8px;
}

.rule-item label {
    flex-grow: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    cursor: pointer;
}

/* Delete Button Styling */
.delete-btn {
    background: transparent;
    border: none;
    color: var(--vscode-description-foreground);
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    line-height: 1;
    padding: 0 6px;
    margin: 0; /* Override global button margin */
    width: auto; /* Override global button width */
    opacity: 0.6;
    transition: opacity 0.2s, color 0.2s;
}

.delete-btn:hover {
    opacity: 1;
    color: var(--vscode-errorForeground); /* Standard VS Code Red */
    background: transparent; /* Override global hover */
}

.hidden {
    display: none;
}

#select-all-container {
    margin-top: 10px;
}

#add-rule-container {
    display: flex;
    margin-top: 10px;
}

#new-rule-input {
    flex-grow: 1;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    padding: 5px;
}

#add-rule-btn {
    flex-grow: 0;
    width: 40px;
    margin-top: 0;
    margin-left: 5px;
    padding: 5px;
}

/* --- NEW STYLES --- */
h2 {
    margin-bottom: 5px;
}

h3 {
    margin-top: 20px;
    margin-bottom: 5px;
}

hr {
    border: none;
    border-top: 1px solid var(--vscode-editor-widget-border);
    margin: 15px 0;
}

.description {
    font-size: var(--vscode-font-size);
    color: var(--vscode-description-foreground);
    margin-top: 0;
    margin-bottom: 5px;
}

/* --- ADD THIS NEW RULE FOR DISABLED BUTTONS --- */
button:disabled {
    cursor: not-allowed;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-disabledForeground);
    opacity: 0.7;
}

.description {
    font-size: var(--vscode-font-size);
    color: var(--vscode-description-foreground);
    margin-top: 0;
    margin-bottom: 5px;
}

button:disabled {
    cursor: not-allowed;
    background-color: var(--vscode-button-secondaryBackground);
    color: var(--vscode-disabledForeground);
    opacity: 0.7;
}

/* --- ADD THIS NEW STYLE FOR CATEGORY HEADERS --- */
.rules-category-header {
    font-weight: bold;
    margin-top: 15px;
    margin-bottom: 5px;
    color: var(--vscode-foreground);
    border-bottom: 1px solid var(--vscode-editor-widget-border);
    padding-bottom: 3px;
}

/* --- NEW STYLES FOR TOGGLE --- */
/* .mode-toggle-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 15px;
    background-color: var(--vscode-editor-inactiveSelectionBackground);
    padding: 10px;
    border-radius: 4px;
}

.mode-option {
    display: flex;
    align-items: flex-start;
}

.mode-option input {
    margin-top: 3px;
    margin-right: 8px;
}

.mode-option label {
    cursor: pointer;
} */

/* --- SEGMENTED CONTROL (TOGGLE) --- */
.toggle-container {
    display: flex;
    justify-content: center;
    align-items: center;
    /* background-color: var(--vscode-button-secondaryBackground); */
    /* background-color: var(--vscode-disabledForeground); */
    padding: 2px;
    border-radius: 4px;
    border-color: white;
    margin-bottom: 20px;
}

.toggle-btn {
    flex: 1;
    border: none;
    background: transparent;
    color: var(--vscode-button-secondaryForeground);
    padding: 6px 12px;
    font-family: var(--vscode-font-family);
    font-size: var(--vscode-font-size);
    cursor: pointer;
    border-radius: 2px;
    transition: background-color 0.2s;
    outline: none;
}

.toggle-btn:hover {
    background-color: var(--vscode-button-secondaryHoverBackground);
}

.toggle-btn.active {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    font-weight: 600;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

/* --- UTILS --- */
.hidden {
    display: none !important;
}

.section-header {
    margin-top: 15px;
    margin-bottom: 10px;
    font-weight: bold;
    opacity: 0.9;
}

/* --- CATEGORY DROPDOWNS (ACCORDION) --- */
.category-group {
    margin-bottom: 5px;
    border: 1px solid var(--vscode-editor-widget-border);
    border-radius: 3px;
    overflow: hidden;
}

.category-header {
    display: flex;
    align-items: center;
    background-color: var(--vscode-sideBarSectionHeader-background);
    padding: 4px 8px;
    cursor: pointer;
    user-select: none;
}

.category-toggle-icon {
    margin-right: 6px;
    font-size: 10px;
    transition: transform 0.2s;
    /* Unicode arrow usually works, or use codicons if available */
    content: '▶'; 
    display: inline-block;
}

.category-group.expanded .category-toggle-icon {
    transform: rotate(90deg);
}

.category-title {
    flex-grow: 1;
    font-weight: bold;
    font-size: 0.9em;
}

/* Specific Select All checkbox for the group */
.category-checkbox {
    margin-left: 8px;
    cursor: pointer;
}

.category-content {
    display: none;
    padding: 5px 0 5px 10px; /* Indent content */
    background-color: var(--vscode-editor-background);
}

.category-group.expanded .category-content {
    display: block;
}

/* Hide the global select all in Exclude mode, since we have per-group controls now */
.global-select-all-hidden {
    display: none;
}

--- media/main.js ---
// media/main.js
(function () {
    const vscode = acquireVsCodeApi();

    // --- INTERNAL STATE ---
    let appState = {
        mode: 'exclude', 
        // Rules now look like: { value: 'node_modules', checked: true, category: 'imported' | 'custom' }
        excludeRules: [], 
        includeRules: []  
    };

    // --- UI REFERENCES ---
    const btnExclude = document.getElementById('btn-mode-exclude');
    const btnInclude = document.getElementById('btn-mode-include');
    const modeDesc = document.getElementById('mode-description');
    
    const excludeControls = document.getElementById('exclude-controls');
    const includeControls = document.getElementById('include-controls');
    
    const rulesSection = document.getElementById('rules-section');
    const listHeader = document.getElementById('list-header');
    const rulesContainer = document.getElementById('rules-container');
    const selectAllContainer = document.getElementById('select-all-container'); // Global select all
    
    const loadTemplateBtn = document.getElementById('load-template-btn');
    const newRuleInput = document.getElementById('new-rule-input');
    const addRuleBtn = document.getElementById('add-rule-btn');
    const selectAllCb = document.getElementById('select-all-cb');
    const generateBtn = document.getElementById('generate-btn');

    // --- INITIALIZATION ---
    vscode.postMessage({ type: 'webview-ready' });

    // --- CORE LOGIC ---

    /**
     * Scrapes DOM to update State.
     * Logic differs for Exclude (Grouped) vs Include (Flat).
     */
    function syncDomToState() {
        if (appState.mode === 'include') {
            // Include mode is still a flat list
            const currentRules = [];
            rulesContainer.querySelectorAll('.rule-item').forEach(item => {
                const cb = item.querySelector('.rule-cb');
                currentRules.push({ value: cb.value, checked: cb.checked, category: 'custom' });
            });
            appState.includeRules = currentRules;
        } else {
            // Exclude mode is grouped. We need to preserve the category.
            const currentRules = [];
            // We can grab all inputs, their category is stored in a data attribute on the item
            rulesContainer.querySelectorAll('.rule-item').forEach(item => {
                const cb = item.querySelector('.rule-cb');
                const category = item.dataset.category || 'custom';
                currentRules.push({ value: cb.value, checked: cb.checked, category: category });
            });
            appState.excludeRules = currentRules;
        }
    }

    /**
     * Renders the list. 
     * If Exclude Mode -> Renders 2 Accordions (Imported, Custom).
     * If Include Mode -> Renders Flat List.
     */
    function renderList() {
        rulesContainer.innerHTML = ''; 
        
        if (appState.mode === 'include') {
            // --- INCLUDE MODE (FLAT) ---
            selectAllContainer.classList.remove('global-select-all-hidden'); // Show global select all
            
            if (appState.includeRules.length > 0) {
                rulesSection.classList.remove('hidden');
                appState.includeRules.forEach(rule => {
                    rulesContainer.appendChild(createRuleItem(rule.value, rule.checked, 'custom'));
                });
            } else {
                rulesSection.classList.remove('hidden'); // Keep visible so they can add
            }

        } else {
            // --- EXCLUDE MODE (GROUPED) ---
            selectAllContainer.classList.add('global-select-all-hidden'); // Hide global select all, use group ones

            const importedRules = appState.excludeRules.filter(r => r.category === 'imported');
            const customRules = appState.excludeRules.filter(r => r.category !== 'imported'); // Default to custom

            let hasContent = false;

            if (importedRules.length > 0) {
                const group = createCategoryGroup('Imported Rules (.gitignore/Template)', importedRules);
                rulesContainer.appendChild(group);
                hasContent = true;
            }

            if (customRules.length > 0) {
                const group = createCategoryGroup('Custom Rules', customRules);
                rulesContainer.appendChild(group);
                hasContent = true;
            }

            // Only show section if we have data or if we want to allow adding
            if (hasContent || customRules.length === 0) {
                 // Even if empty, show section so user can add custom rules
                rulesSection.classList.remove('hidden');
            } else {
                rulesSection.classList.add('hidden');
            }
        }
        
        updateGenerateButtonState();
        // Update global select all for Include mode
        if (appState.mode === 'include') updateGlobalSelectAllState();
    }

    /**
     * Creates a collapsible accordion DOM element
     */
    function createCategoryGroup(title, rules) {
        const groupDiv = document.createElement('div');
        groupDiv.className = 'category-group expanded'; // Default expanded

        // HEADER
        const header = document.createElement('div');
        header.className = 'category-header';
        
        // Collapse Icon
        const icon = document.createElement('span');
        icon.className = 'category-toggle-icon';
        icon.textContent = '▶'; 
        
        // Title
        const titleSpan = document.createElement('span');
        titleSpan.className = 'category-title';
        titleSpan.textContent = title;

        // Group Select All
        const groupCb = document.createElement('input');
        groupCb.type = 'checkbox';
        groupCb.className = 'category-checkbox';
        groupCb.title = 'Select/Deselect All in Group';
        
        // Logic for initial Group Checkbox state
        const allChecked = rules.every(r => r.checked);
        const someChecked = rules.some(r => r.checked);
        groupCb.checked = allChecked;
        groupCb.indeterminate = someChecked && !allChecked;

        // EVENT: Toggle Collapse
        header.addEventListener('click', (e) => {
            if (e.target !== groupCb) {
                groupDiv.classList.toggle('expanded');
            }
        });

        // EVENT: Group Select All
        groupCb.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            const contentDiv = groupDiv.querySelector('.category-content');
            contentDiv.querySelectorAll('.rule-cb').forEach(cb => {
                cb.checked = isChecked;
            });
            syncDomToState();
            saveStateToExtension();
            updateGenerateButtonState();
        });

        header.appendChild(icon);
        header.appendChild(titleSpan);
        header.appendChild(groupCb);

        // CONTENT
        const content = document.createElement('div');
        content.className = 'category-content';
        
        rules.forEach(rule => {
            content.appendChild(createRuleItem(rule.value, rule.checked, rule.category));
        });

        groupDiv.appendChild(header);
        groupDiv.appendChild(content);

        return groupDiv;
    }

    // --- NEW: Delete Logic ---
    function deleteRule(valueToDelete) {
        // 1. Sync current checkbox states so we don't lose checkmarks on other items
        syncDomToState();

        // 2. Filter out the item
        if (appState.mode === 'include') {
            appState.includeRules = appState.includeRules.filter(r => r.value !== valueToDelete);
        } else {
            appState.excludeRules = appState.excludeRules.filter(r => r.value !== valueToDelete);
        }

        // 3. Re-render
        renderList();
        saveStateToExtension();
    }

    // --- UPDATED: Create Rule Item ---
    function createRuleItem(ruleValue, isChecked, category) {
        const ruleItem = document.createElement('div');
        ruleItem.className = 'rule-item';
        ruleItem.dataset.category = category;

        // 1. Checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'rule-cb';
        checkbox.id = ruleValue;
        checkbox.value = ruleValue;
        checkbox.checked = isChecked;
        
        // 2. Label
        const label = document.createElement('label');
        label.htmlFor = ruleValue;
        label.textContent = ruleValue;
        label.title = ruleValue; // Tooltip for long paths

        ruleItem.appendChild(checkbox);
        ruleItem.appendChild(label);

        // 3. Delete Button (Condition: Include Mode OR Custom Category)
        if (appState.mode === 'include' || category === 'custom') {
            const delBtn = document.createElement('button');
            delBtn.className = 'delete-btn';
            delBtn.innerHTML = '&times;'; // The "X" symbol
            delBtn.title = 'Remove this rule';
            
            delBtn.addEventListener('click', (e) => {
                e.preventDefault(); // Prevent triggering label click
                deleteRule(ruleValue);
            });

            ruleItem.appendChild(delBtn);
        }

        return ruleItem;
    }

    // --- UI HELPERS ---

    function updateUiForMode(mode) {
        if (mode === 'exclude') {
            btnExclude.classList.add('active');
            btnInclude.classList.remove('active');
            modeDesc.innerHTML = `<strong>Blacklist:</strong> Everything is included by default. Check items below to <em>exclude</em> them.`;
            excludeControls.classList.remove('hidden');
            includeControls.classList.add('hidden');
            listHeader.textContent = "2. Refine Exclusions";
        } else {
            btnInclude.classList.add('active');
            btnExclude.classList.remove('active');
            modeDesc.innerHTML = `<strong>Whitelist:</strong> Everything is ignored by default. Add items below to <em>include</em> them.`;
            excludeControls.classList.add('hidden');
            includeControls.classList.remove('hidden');
            listHeader.textContent = "2. Whitelist Files";
        }
    }

    // --- ACTIONS ---

    function handleModeSwitch(newMode) {
        if (appState.mode === newMode) return;
        syncDomToState();
        appState.mode = newMode;
        updateUiForMode(newMode);
        renderList();
        saveStateToExtension();
    }

    function addNewRule() {
        let newRule = newRuleInput.value.trim();
        if (!newRule) return;

        // Auto format
        if (newRule.startsWith('.') && !newRule.includes('*') && !newRule.includes('/')) {
            newRule = '*' + newRule;
        }

        // Logic split for Adding
        if (appState.mode === 'include') {
            // Include mode (Flat)
            if (!appState.includeRules.find(r => r.value === newRule)) {
                appState.includeRules.unshift({ value: newRule, checked: true, category: 'custom' });
                renderList();
                saveStateToExtension();
            }
        } else {
            // Exclude mode (Grouped) - Add to Custom
            if (!appState.excludeRules.find(r => r.value === newRule)) {
                appState.excludeRules.unshift({ value: newRule, checked: true, category: 'custom' });
                renderList();
                saveStateToExtension();
            }
        }
        newRuleInput.value = '';
    }

    // --- EVENTS ---

    btnExclude.addEventListener('click', () => handleModeSwitch('exclude'));
    btnInclude.addEventListener('click', () => handleModeSwitch('include'));

    loadTemplateBtn.addEventListener('click', () => {
        loadTemplateBtn.disabled = true;
        loadTemplateBtn.textContent = 'Loading...';
        vscode.postMessage({ type: 'load-template' });
    });

    addRuleBtn.addEventListener('click', addNewRule);
    newRuleInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addNewRule(); });

    // Listener for individual Rule Checkboxes
    rulesContainer.addEventListener('change', (e) => {
        if (e.target.classList.contains('rule-cb')) {
            
            // If inside a group, update that group's select all checkbox
            const groupDiv = e.target.closest('.category-group');
            if (groupDiv) {
                const groupCb = groupDiv.querySelector('.category-checkbox');
                const allCbs = groupDiv.querySelectorAll('.rule-cb');
                const allChecked = Array.from(allCbs).every(cb => cb.checked);
                const someChecked = Array.from(allCbs).some(cb => cb.checked);
                groupCb.checked = allChecked;
                groupCb.indeterminate = someChecked && !allChecked;
            }

            updateGenerateButtonState();
            if (appState.mode === 'include') updateGlobalSelectAllState();
            syncDomToState();
            saveStateToExtension();
        }
    });

    // Global Select All (Only used for Include Mode now)
    selectAllCb.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        rulesContainer.querySelectorAll('.rule-cb').forEach(cb => cb.checked = isChecked);
        updateGenerateButtonState();
        syncDomToState();
        saveStateToExtension();
    });

    generateBtn.addEventListener('click', () => {
        syncDomToState(); 
        const activeRules = appState.mode === 'exclude' ? appState.excludeRules : appState.includeRules;
        const selectedRules = activeRules.filter(r => r.checked).map(r => r.value);

        vscode.postMessage({ 
            type: 'generate', 
            rules: selectedRules,
            mode: appState.mode
        });
    });

    // --- MESSAGES ---

    window.addEventListener('message', event => {
        const message = event.data;
        switch (message.type) {
            case 'restore-state':
                if (message.state) {
                    appState = message.state;
                    // Defaults
                    if (!appState.excludeRules) appState.excludeRules = [];
                    if (!appState.includeRules) appState.includeRules = [];
                    if (!appState.mode) appState.mode = 'exclude';
                    
                    updateUiForMode(appState.mode);
                    renderList();
                }
                break;

            case 'update-rules':
                // Loading templates (Exclude Mode)
                const { local, template } = message.rules;
                const newRules = [];
                
                // Tag them as 'imported'
                local.forEach(r => newRules.push({ value: r, checked: true, category: 'imported' }));
                template.rules.forEach(r => newRules.push({ value: r, checked: true, category: 'imported' }));
                
                // Preserve existing custom rules? 
                // Currently we overwrite imported, but we should probably keep custom rules user added
                const existingCustom = appState.excludeRules.filter(r => r.category === 'custom');
                appState.excludeRules = [...newRules, ...existingCustom];
                
                appState.mode = 'exclude';
                loadTemplateBtn.textContent = 'Reload Rules';
                loadTemplateBtn.disabled = false;

                updateUiForMode('exclude');
                renderList();
                saveStateToExtension();
                break;
        }
    });

    function saveStateToExtension() {
        vscode.postMessage({ type: 'save-state', state: appState });
    }

    function updateGlobalSelectAllState() {
        const checkboxes = rulesContainer.querySelectorAll('.rule-cb');
        if (checkboxes.length === 0) return;
        selectAllCb.checked = Array.from(checkboxes).every(cb => cb.checked);
    }

    function updateGenerateButtonState() {
        const checkedBoxes = rulesContainer.querySelectorAll('.rule-cb:checked');
        const count = checkedBoxes.length;

        if (count === 0) {
            generateBtn.disabled = true;
            generateBtn.title = "Select at least one item";
        } else {
            generateBtn.disabled = false;
            generateBtn.title = "";
        }
    }

}());

--- package.json ---
{
  "name": "code-context-extractor",
  "displayName": "Code Context Extractor",
  "description": "Generates a single text file of your project context for LLMs. Supports both Whitelist and Blacklist modes with smart binary exclusion.",
  "version": "1.1.0",
  "publisher": "ct-dev",
  "icon": "media/icon.png",
  "repository": {
    "type": "git",
    "url": "https://github.com/Buezeth/code-context-extractor"
  },
  "license": "MIT",
  "engines": {
    "vscode": "^1.105.0"
  },
  "categories": [
    "Other",
    "Machine Learning",
    "Programming Languages"
  ],
  "activationEvents": [
    "onCommand:code-context-extractor.generate",
    "onView:code-context-extractor-view"
  ],
  "main": "./dist/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "code-context-extractor.generate",
        "title": "Code Context: Generate Project Context File"
      }
    ],
    "configuration": {
      "title": "Code Context Extractor",
      "properties": {
        "code-context-extractor.useGitignoreTemplates": {
          "type": "boolean",
          "default": true,
          "description": "Automatically suggest and use .gitignore templates from GitHub to determine which files to exclude."
        },
        "code-context-extractor.excludeDirs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "default": [
            ".git",
            ".vscode"
          ],
          "description": "List of directory names to exclude by default in Exclude Mode."
        },
        "code-context-extractor.excludeFiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "default": [
            "package-lock.json"
          ],
          "description": "List of specific file names to exclude by default in Exclude Mode."
        }
      }
    },
    "viewsContainers": {
      "activitybar": [
        {
          "id": "code-context-extractor-sidebar",
          "title": "Code Context Extractor",
          "icon": "media/icon.svg"
        }
      ]
    },
    "views": {
      "code-context-extractor-sidebar": [
        {
          "id": "code-context-extractor-view",
          "name": "Generator",
          "type": "webview",
          "icon": "media/icon.svg"
        }
      ]
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run package",
    "compile": "npm run check-types && npm run lint && node esbuild.js",
    "watch": "npm-run-all -p watch:*",
    "watch:esbuild": "node esbuild.js --watch",
    "watch:tsc": "tsc --noEmit --watch --project tsconfig.json",
    "package": "npm run check-types && npm run lint && node esbuild.js --production",
    "compile-tests": "tsc -p . --outDir out",
    "watch-tests": "tsc -p . -w --outDir out",
    "pretest": "npm run compile-tests && npm run compile && npm run lint",
    "check-types": "tsc --noEmit",
    "lint": "eslint src",
    "test": "vscode-test"
  },
  "devDependencies": {
    "@types/mocha": "^10.0.10",
    "@types/node": "22.x",
    "@types/node-fetch": "^2.6.13",
    "@types/vscode": "^1.105.0",
    "@typescript-eslint/eslint-plugin": "^8.45.0",
    "@typescript-eslint/parser": "^8.45.0",
    "@vscode/test-cli": "^0.0.11",
    "@vscode/test-electron": "^2.5.2",
    "esbuild": "^0.25.10",
    "eslint": "^9.36.0",
    "npm-run-all": "^4.1.5",
    "typescript": "^5.9.3"
  },
  "dependencies": {
    "ignore": "^7.0.5",
    "node-fetch": "^2.7.0"
  }
}


--- README.md ---
# Code Context Extractor

**Code Context Extractor** is a Visual Studio Code extension designed to streamline the process of feeding codebases into Large Language Models (LLMs) like GPT-4, Claude, or Gemini.

It generates a single, formatted text file (`ProjectContext.txt`) containing your project's folder structure and file contents, filtering out unnecessary noise and binary files to save tokens.

## Key Features

*   **Dual Operation Modes**:
    *   **Blacklist (Exclude) Mode**: Best for general project context. Everything is included by default; you select what to hide (e.g., `node_modules`, secrets, logs).
    *   **Whitelist (Include) Mode**: Best for specific tasks. Start with nothing. Select *only* the specific files or folders you need for a specific bug or feature.
*   **Smart Grouping**: In Exclude mode, rules are organized into "Imported Rules" (from `.gitignore`/Templates) and "Custom Rules" for better manageability.
*   **Binary File Detection**: Automatically detects binary files (images, PDFs, executables) and excludes their raw content to prevent "garbage" text in your context file.
*   **GitHub Templates**: Built-in access to standard `.gitignore` templates (Node, Python, Go, etc.) for quick setup.
*   **State Persistence**: Remembers your selection, custom rules, and active mode between sessions.

## How to Use

1.  Open the **Code Context Extractor** view from the VS Code Activity Bar (Sidebar).

### Mode 1: Exclude (Blacklist)
*Use this when you want to share the whole project but hide specific clutter.*

1.  Select **"Exclude Mode"** at the top.
2.  Click **"Load .gitignore & Templates"**. This imports rules from your project's `.gitignore`, VS Code settings, and optionally a GitHub template.
3.  **Refine the List**:
    *   **Imported Rules**: Expand the group to see standard exclusions. Uncheck items to *include* them back into the context.
    *   **Custom Rules**: Type a folder or file name (e.g., `temp/` or `*.log`) and press Enter to add it. You can delete these later using the **×** button.
4.  Click **"Generate Context File"**.

### Mode 2: Include (Whitelist)
*Use this when you want to focus on a specific feature.*

1.  Select **"Include Mode"** at the top.
2.  The list starts empty (everything is ignored by default).
3.  **Add Files**: Type specific folder names (e.g., `src/utils/`) or file names (e.g., `package.json`) and press Enter.
4.  Only the items in this list (and their contents) will be written to the output file.
5.  Click **"Generate Context File"**.

## Output

A `ProjectContext.txt` file is created in your root directory and opened automatically. It contains:
1.  A visual tree of your folder structure.
2.  The text content of every allowed file, formatted with headers for easy LLM parsing.

## Extension Settings

This extension contributes the following settings:

*   `code-context-extractor.excludeDirs`: List of directory names to exclude by default in Exclude Mode (e.g., `.git`, `.vscode`).
*   `code-context-extractor.excludeFiles`: List of file names to exclude by default in Exclude Mode (e.g., `package-lock.json`).
*   `code-context-extractor.useGitignoreTemplates`: Enable/Disable the GitHub template fetcher.

## Release Notes

### 1.1.0
- **Major Feature Update**:
    - Introduced **Whitelist (Include) Mode** for targeted context extraction.
    - Added **Binary File Detection** to prevent binary content corruption.
    - **UI Overhaul**: Added collapsible "Accordion" groups for Imported vs. Custom rules.
    - Added ability to **Delete** custom rules.
    - Improved state persistence and checkbox logic.

### 0.0.1
- Initial release.

--- src/contextGenerator.ts ---
// src/contextGenerator.ts

import * as fs from 'fs';
import * as path from 'path';
import type { Ignore } from 'ignore';

/**
 * Simple heuristic to detect if a file is binary.
 * 1. Checks extension.
 * 2. Checks for null bytes in the first 4KB.
 */
function isBinaryFile(filePath: string): boolean {
    // 1. Quick check based on extension
    const binaryExtensions = [
        '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.ico', '.webp',
        '.pdf', '.exe', '.dll', '.so', '.dylib', '.bin',
        '.zip', '.tar', '.gz', '.7z', '.rar',
        '.mp3', '.mp4', '.wav', '.avi', '.mov',
        '.eot', '.ttf', '.woff', '.woff2',
        '.pyc', '.class', '.jar'
    ];
    
    if (binaryExtensions.includes(path.extname(filePath).toLowerCase())) {
        return true;
    }

    // 2. Content check (Null Byte Heuristic)
    try {
        const buffer = Buffer.alloc(4096);
        const fd = fs.openSync(filePath, 'r');
        const bytesRead = fs.readSync(fd, buffer, 0, 4096, 0);
        fs.closeSync(fd);

        // Empty file is treated as text
        if (bytesRead === 0) {
            return false;
        }

        // Look for null byte (0x00) which usually indicates binary
        for (let i = 0; i < bytesRead; i++) {
            if (buffer[i] === 0) {
                return true;
            }
        }
        return false;
    } catch (err) {
        // If we can't read it, assume safe to skip or treat as binary to be safe
        return false; 
    }
}

export function generateProjectContextText(
    projectPath: string,
    outputFile: string,
    ig: Ignore 
): Promise<void> {
    return new Promise((resolve, reject) => {
        try {
            const outputStream = fs.createWriteStream(outputFile, { encoding: "utf8" });

            outputStream.write("--- START OF FILE ProjectContext.txt ---\n\n");
            outputStream.write("--- Folder Structure ---\n");
            
            function walkDir(dir: string, indent: string = ""): void {
                let entries;
                try {
                    entries = fs.readdirSync(dir, { withFileTypes: true });
                } catch (err) { return; }
            
                entries.sort((a, b) => a.name.localeCompare(b.name));
            
                for (const entry of entries) {
                    const fullPath = path.join(dir, entry.name);
                    const relativePath = path.relative(projectPath, fullPath).replace(/\\/g, '/');

                    if (entry.isDirectory()) {
                        if (ig.ignores(relativePath + '/')) {
                            continue;
                        }
                        outputStream.write(`${indent}${entry.name}/\n`);
                        walkDir(fullPath, indent + "  ");
                    } else {
                        if (ig.ignores(relativePath)) {
                            continue;
                        }
                        // File names are written in the structure section, content comes later
                    }
                }
            }

            function writeIncludedFileContents(dir: string): void {
                let entries;
                try {
                    entries = fs.readdirSync(dir, { withFileTypes: true });
                } catch (err) { return; }
                
                entries.sort((a, b) => a.name.localeCompare(b.name));

                for (const entry of entries) {
                    const fullPath = path.join(dir, entry.name);
                    const relativePath = path.relative(projectPath, fullPath).replace(/\\/g, '/');
                    
                    if (entry.isDirectory()) {
                        if (ig.ignores(relativePath + '/')) {
                            continue;
                        }
                        writeIncludedFileContents(fullPath);
                    } else if (entry.isFile()) {
                        if (ig.ignores(relativePath)) {
                            continue;
                        }

                        outputStream.write(`\n--- ${relativePath} ---\n`);

                        // --- FIX START: Check for binary files ---
                        if (isBinaryFile(fullPath)) {
                            outputStream.write("[Binary file detected - content excluded]\n");
                            continue;
                        }
                        // --- FIX END ---

                        try {
                            const content = fs.readFileSync(fullPath, "utf8");
                            outputStream.write(content + "\n");
                        } catch (err) {
                            outputStream.write(`[Error reading file: ${(err as Error).message}]\n`);
                        }
                    }
                }
            }

            walkDir(projectPath);
            outputStream.write("\n");
            writeIncludedFileContents(projectPath);

            outputStream.end(() => resolve());
            outputStream.on('error', reject);

        } catch (error) {
            reject(error);
        }
    });
}

--- src/extension.ts ---
// src/extension.ts

import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { generateProjectContextText } from './contextGenerator';
import { getAvailableTemplates, getTemplateContent, detectProjectTypes } from './gitignoreProvider';
import ignore from 'ignore';
import { SidebarProvider } from './SidebarProvider';

export function activate(context: vscode.ExtensionContext) {

    const sidebarProvider = new SidebarProvider(context.extensionUri, context.workspaceState);
    context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(SidebarProvider.viewType, sidebarProvider)
    );

    // COMMAND 1: Load Templates (Mostly for Exclude Mode)
    const loadTemplateCommand = vscode.commands.registerCommand('code-context-extractor.loadTemplateRules', async () => {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            vscode.window.showErrorMessage('No workspace folder is open.');
            return {};
        }
        const projectRoot = workspaceFolders[0].uri.fsPath;

        const localRules = new Set<string>();
        const templateRules = new Set<string>();
        let templateName = '';

        // Helper to parse line-by-line
        const addRulesToSet = (content: string, ruleSet: Set<string>) => {
            content.split(/\r?\n/).forEach(line => {
                const trimmed = line.trim();
                if (trimmed && !trimmed.startsWith('#')) {
                    ruleSet.add(trimmed);
                }
            });
        };

        // 1. Add rules from local .gitignore and Settings
        const localGitignorePath = path.join(projectRoot, '.gitignore');
        if (fs.existsSync(localGitignorePath)) {
            const localGitignoreContent = fs.readFileSync(localGitignorePath, 'utf8');
            addRulesToSet(localGitignoreContent, localRules);
        }
        const configuration = vscode.workspace.getConfiguration('code-context-extractor');
        const excludeDirs = configuration.get<string[]>('excludeDirs', []);
        const excludeFiles = configuration.get<string[]>('excludeFiles', []);
        
        excludeDirs.map(dir => `${dir}/`).forEach(rule => localRules.add(rule));
        excludeFiles.forEach(rule => localRules.add(rule));

        // 2. Ask user to select a GitHub template (Optional)
        const templates = await getAvailableTemplates();
        if (templates.length > 0) {
            const detected = await detectProjectTypes(projectRoot);
            const detectedSet = new Set(detected.map(d => d.toLowerCase()));
            const suggestedTemplates: vscode.QuickPickItem[] = [];
            const otherTemplates: vscode.QuickPickItem[] = [];

            templates.sort((a, b) => a.localeCompare(b));

            templates.forEach(template => {
                if (detectedSet.has(template.toLowerCase())) {
                    suggestedTemplates.push({
                        label: template,
                        description: '(Suggested for your project)'
                    });
                } else {
                    otherTemplates.push({ label: template });
                }
            });

            const allItems = [...suggestedTemplates, ...otherTemplates];
            const selectedTemplateItem = await vscode.window.showQuickPick(allItems, {
                canPickMany: false,
                placeHolder: 'Select a template to add its rules (optional)',
                title: 'Choose a .gitignore Template'
            });

            if (selectedTemplateItem) {
                templateName = selectedTemplateItem.label;
                const content = await getTemplateContent(templateName);
                addRulesToSet(content, templateRules);
            }
        }
        
        // De-duplicate: If a rule exists in local, don't show it as 'template'
        const finalTemplateRules = new Set<string>();
        templateRules.forEach(rule => {
            if (!localRules.has(rule)) {
                finalTemplateRules.add(rule);
            }
        });

        return {
            local: Array.from(localRules).sort(),
            template: {
                name: templateName,
                rules: Array.from(finalTemplateRules).sort()
            }
        };
    });

    /**
     * COMMAND 2: Generate Context File
     * Handles both 'exclude' (blacklist) and 'include' (whitelist) logic.
     */
    const generateCommand = vscode.commands.registerCommand('code-context-extractor.generate', async (args?: { selectedRules?: string[], mode?: 'include' | 'exclude' }) => {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            vscode.window.showErrorMessage('No workspace folder is open.');
            return;
        }
        const projectRoot = workspaceFolders[0].uri.fsPath;
        const outputFilePath = path.join(projectRoot, 'ProjectContext.txt');
        
        const ig = ignore();

        // 1. Safety: Always exclude the output file itself
        ig.add('ProjectContext.txt');

        const mode = args?.mode || 'exclude';
        const rules = args?.selectedRules || [];

        if (mode === 'include') {
            // --- WHITELIST STRATEGY ---
            // 1. Ignore everything (*)
            ig.add('*'); 
            
            if (rules.length > 0) {
                rules.forEach(rule => {
                    const rawRule = rule.startsWith('!') ? rule.substring(1) : rule;
                    
                    // 2. Un-ignore (!) the specific item
                    ig.add(`!${rawRule}`);

                    // 3. If it's a folder, recursively un-ignore contents (**)
                    if (rawRule.endsWith('/')) {
                        ig.add(`!${rawRule}**`);
                    }
                });
            } else {
                vscode.window.showWarningMessage("Include Mode: No files selected. Output will be empty.");
                return;
            }

        } else {
            // --- BLACKLIST STRATEGY (Standard .gitignore) ---
            ig.add('.git/'); // Always exclude .git metadata
            
            if (rules.length > 0) {
                ig.add(rules);
            } else {
                const decision = await vscode.window.showWarningMessage(
                    "Exclude Mode: No files selected. This will include EVERYTHING (including node_modules). Continue?",
                    { modal: true }, 'Yes, Continue'
                );
                if (decision !== 'Yes, Continue') {
                    return;
                } 
            }
        }
        
        await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: `Generating Context (${mode === 'include' ? 'Whitelist' : 'Blacklist'})`,
            cancellable: false
        }, async (progress) => {
            progress.report({ message: 'Scanning files...' });
            try {
                await generateProjectContextText(projectRoot, outputFilePath, ig);
                vscode.window.showInformationMessage('Successfully generated ProjectContext.txt!');
                await vscode.window.showTextDocument(vscode.Uri.file(outputFilePath));
            } catch (error) {
                vscode.window.showErrorMessage(`Failed to generate context: ${(error as Error).message}`);
            }
        });
    });

    context.subscriptions.push(loadTemplateCommand, generateCommand);
}

export function deactivate() {}

--- src/gitignoreProvider.ts ---
// src/gitignoreProvider.ts

import * as vscode from 'fs';
import * as path from 'path';
import fetch from 'node-fetch';

// Simple in-memory cache to avoid hitting the GitHub API too often
let templateCache: string[] | null = null;

const API_URL = 'https://api.github.com/repos/github/gitignore/contents/';

/**
 * Fetches the list of available .gitignore templates from the GitHub API.
 * Results are cached in memory.
 */
export async function getAvailableTemplates(): Promise<string[]> {
    if (templateCache) {
        return templateCache;
    }

    try {
        const response = await fetch(API_URL);
        if (!response.ok) {
            throw new Error(`GitHub API returned ${response.status}`);
        }
        const files = await response.json() as { name: string, type: string }[];
        
        const templateNames = files
            .filter(file => file.type === 'file' && file.name.endsWith('.gitignore'))
            .map(file => file.name.replace('.gitignore', ''));

        templateCache = templateNames;
        return templateNames;
    } catch (error) {
        console.error('Failed to fetch gitignore templates:', error);
        return []; // Return empty on error
    }
}

/**
 * Fetches the content of a specific .gitignore template.
 */
export async function getTemplateContent(templateName: string): Promise<string> {
    const url = `https://raw.githubusercontent.com/github/gitignore/main/${templateName}.gitignore`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            return ''; // Return empty string if a template can't be fetched
        }
        return await response.text();
    } catch (error) {
        console.error(`Failed to fetch content for ${templateName}:`, error);
        return '';
    }
}

/**
 * Scans the project root for common files to detect the project type.
 */
export async function detectProjectTypes(projectRoot: string): Promise<string[]> {
    const detections: { [key: string]: string } = {
        'Node': 'package.json',
        'Python': 'requirements.txt',
        'Go': 'go.mod',
        'Rust': 'Cargo.toml',
        'Java': 'pom.xml',
        'Maven': 'pom.xml'
    };

    const detectedTypes: string[] = [];
    for (const type in detections) {
        const file = detections[type];
        try {
            await vscode.promises.stat(path.join(projectRoot, file));
            detectedTypes.push(type);
        } catch (error) {
            // File doesn't exist, so we don't detect this type.
        }
    }
    return detectedTypes;
}

--- src/SidebarProvider.ts ---
// src/SidebarProvider.ts

import * as vscode from 'vscode';

export class SidebarProvider implements vscode.WebviewViewProvider {
    public static readonly viewType = 'code-context-extractor-view';
    private _view?: vscode.WebviewView;

    constructor(
        private readonly _extensionUri: vscode.Uri,
        private readonly _workspaceState: vscode.Memento 
    ) {}

    public async resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        _token: vscode.CancellationToken,
    ) {
        this._view = webviewView;

        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [this._extensionUri]
        };

        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

        webviewView.webview.onDidReceiveMessage(async (data) => {
            switch (data.type) {
                // Restore state when Webview reports it is ready
                case 'webview-ready': {
                    const savedState = this._workspaceState.get('sidebarState');
                    if (savedState) {
                        this._view?.webview.postMessage({ type: 'restore-state', state: savedState });
                    }
                    break;
                }
                case 'generate': {
                    vscode.commands.executeCommand('code-context-extractor.generate', {
                        selectedRules: data.rules,
                        mode: data.mode
                    });
                    break;
                }
                case 'load-template': {
                    const rules = await vscode.commands.executeCommand<string[]>('code-context-extractor.loadTemplateRules');
                    if (rules && this._view) {
                        this._view.webview.postMessage({ type: 'update-rules', rules: rules });
                    }
                    break;
                }
                case 'save-state': {
                    await this._workspaceState.update('sidebarState', data.state);
                    break;
                }
            }
        });
    }

    private _getHtmlForWebview(webview: vscode.Webview) {
        const scriptUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'main.js'));
        const styleUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'media', 'main.css'));
        const nonce = getNonce();

        return `<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource}; script-src 'nonce-${nonce}';">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <link href="${styleUri}" rel="stylesheet">
                <title>Code Context Extractor</title>
            </head>
            <body>
                <h2>Context Generator</h2>
                
                <!-- MODE TOGGLE -->
                <div class="toggle-container">
                    <button id="btn-mode-exclude" class="toggle-btn active">Exclude Mode</button>
                    <button id="btn-mode-include" class="toggle-btn">Include Mode</button>
                </div>

                <p id="mode-description" class="description">
                    <strong>Blacklist:</strong> Select files you want to <em>hide</em>.
                </p>

                <hr>

                <!-- EXCLUDE CONTROLS -->
                <div id="exclude-controls">
                    <h4 class="section-header">1. Load Ignore Rules</h4>
                    <button id="load-template-btn">Load .gitignore & Templates</button>
                </div>

                <!-- INCLUDE CONTROLS -->
                <div id="include-controls" class="hidden">
                    <h4 class="section-header">1. Add Files to Include</h4>
                    <p class="description">Start empty. Add specific folders (e.g., <code>src/</code>) or files you strictly need.</p>
                </div>

                <!-- LIST MANAGEMENT -->
                <div id="rules-section" class="hidden">
                    <h4 class="section-header" id="list-header">2. Manage List</h4>
                    
                    <div id="add-rule-container">
                        <input type="text" id="new-rule-input" placeholder="e.g. src/ or *.ts"/>
                        <button id="add-rule-btn">+</button>
                    </div>

                    <div id="select-all-container">
                        <input type="checkbox" id="select-all-cb" checked>
                        <label for="select-all-cb">Select / Deselect All</label>
                    </div>
                    
                    <div id="rules-container"></div>
                </div>

                <!-- GENERATE ACTION -->
                <div id="generate-section">
                    <hr>
                    <button id="generate-btn" disabled>Generate Context File</button>
                </div>

                <script nonce="${nonce}" src="${scriptUri}"></script>
            </body>
            </html>`;
    }
}

function getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}

--- src/test/extension.test.ts ---
import * as assert from 'assert';

// You can import and use all API from the 'vscode' module
// as well as import your extension to test it
import * as vscode from 'vscode';
// import * as myExtension from '../../extension';

suite('Extension Test Suite', () => {
	vscode.window.showInformationMessage('Start all tests.');

	test('Sample test', () => {
		assert.strictEqual(-1, [1, 2, 3].indexOf(5));
		assert.strictEqual(-1, [1, 2, 3].indexOf(0));
	});
});


--- tsconfig.json ---
{
	"compilerOptions": {
		"module": "Node16",
		"target": "ES2022",
		"lib": [
			"ES2022"
		],
		"sourceMap": true,
		"rootDir": "src",
		"strict": true,   /* enable all strict type-checking options */
		/* Additional Checks */
		// "noImplicitReturns": true, /* Report error when not all code paths in function return a value. */
		// "noFallthroughCasesInSwitch": true, /* Report errors for fallthrough cases in switch statement. */
		// "noUnusedParameters": true,  /* Report errors on unused parameters. */
		"skipLibCheck": true, /* Skip type checking of declaration files. */
	},
    "exclude": [      // <--- ADD THIS BLOCK
        "node_modules"
    ]
}


--- vsc-extension-quickstart.md ---
# Welcome to your VS Code Extension

## What's in the folder

* This folder contains all of the files necessary for your extension.
* `package.json` - this is the manifest file in which you declare your extension and command.
  * The sample plugin registers a command and defines its title and command name. With this information VS Code can show the command in the command palette. It doesn’t yet need to load the plugin.
* `src/extension.ts` - this is the main file where you will provide the implementation of your command.
  * The file exports one function, `activate`, which is called the very first time your extension is activated (in this case by executing the command). Inside the `activate` function we call `registerCommand`.
  * We pass the function containing the implementation of the command as the second parameter to `registerCommand`.

## Setup

* install the recommended extensions (amodio.tsl-problem-matcher, ms-vscode.extension-test-runner, and dbaeumer.vscode-eslint)


## Get up and running straight away

* Press `F5` to open a new window with your extension loaded.
* Run your command from the command palette by pressing (`Ctrl+Shift+P` or `Cmd+Shift+P` on Mac) and typing `Hello World`.
* Set breakpoints in your code inside `src/extension.ts` to debug your extension.
* Find output from your extension in the debug console.

## Make changes

* You can relaunch the extension from the debug toolbar after changing code in `src/extension.ts`.
* You can also reload (`Ctrl+R` or `Cmd+R` on Mac) the VS Code window with your extension to load your changes.


## Explore the API

* You can open the full set of our API when you open the file `node_modules/@types/vscode/index.d.ts`.

## Run tests

* Install the [Extension Test Runner](https://marketplace.visualstudio.com/items?itemName=ms-vscode.extension-test-runner)
* Run the "watch" task via the **Tasks: Run Task** command. Make sure this is running, or tests might not be discovered.
* Open the Testing view from the activity bar and click the Run Test" button, or use the hotkey `Ctrl/Cmd + ; A`
* See the output of the test result in the Test Results view.
* Make changes to `src/test/extension.test.ts` or create new test files inside the `test` folder.
  * The provided test runner will only consider files matching the name pattern `**.test.ts`.
  * You can create folders inside the `test` folder to structure your tests any way you want.

## Go further

* Reduce the extension size and improve the startup time by [bundling your extension](https://code.visualstudio.com/api/working-with-extensions/bundling-extension).
* [Publish your extension](https://code.visualstudio.com/api/working-with-extensions/publishing-extension) on the VS Code extension marketplace.
* Automate builds by setting up [Continuous Integration](https://code.visualstudio.com/api/working-with-extensions/continuous-integration).

